<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>UCX: UCP Memory routines</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="UCX_Logo_80x80.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">UCX
   &#160;<span id="projectnumber">1.14</span>
   </div>
   <div id="projectbrief">Unified Communication X</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Programming&#160;Interface</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___u_c_p___m_e_m.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">UCP Memory routines<div class="ingroups"><a class="el" href="group___u_c_p___a_p_i.html">Unified Communication Protocol (UCP) API</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structucp__mem__map__params"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___m_e_m.html#structucp__mem__map__params">ucp_mem_map_params</a></td></tr>
<tr class="memdesc:structucp__mem__map__params"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tuning parameters for the UCP memory mapping.  <a href="group___u_c_p___m_e_m.html#structucp__mem__map__params">More...</a><br /></td></tr>
<tr class="separator:structucp__mem__map__params"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structucp__mem__advise__params"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___m_e_m.html#structucp__mem__advise__params">ucp_mem_advise_params</a></td></tr>
<tr class="memdesc:structucp__mem__advise__params"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tuning parameters for the UCP memory advice.  <a href="group___u_c_p___m_e_m.html#structucp__mem__advise__params">More...</a><br /></td></tr>
<tr class="separator:structucp__mem__advise__params"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structucp__memh__pack__params"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___m_e_m.html#structucp__memh__pack__params">ucp_memh_pack_params</a></td></tr>
<tr class="memdesc:structucp__memh__pack__params"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory handle pack parameters passed to <a class="el" href="group___u_c_p___m_e_m.html#ga8540eb3c5b885dfddbca0e39e00117ad">ucp_memh_pack</a>.  <a href="group___u_c_p___m_e_m.html#structucp__memh__pack__params">More...</a><br /></td></tr>
<tr class="separator:structucp__memh__pack__params"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structucp__memh__buffer__release__params"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___m_e_m.html#structucp__memh__buffer__release__params">ucp_memh_buffer_release_params</a></td></tr>
<tr class="memdesc:structucp__memh__buffer__release__params"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory handle release parameters passed to <a class="el" href="group___u_c_p___m_e_m.html#gab016c446e78e171c03a2fe11ab5fe48d">ucp_memh_buffer_release</a>.  <a href="group___u_c_p___m_e_m.html#structucp__memh__buffer__release__params">More...</a><br /></td></tr>
<tr class="separator:structucp__memh__buffer__release__params"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structucp__mem__attr"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___m_e_m.html#structucp__mem__attr">ucp_mem_attr</a></td></tr>
<tr class="memdesc:structucp__mem__attr"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes of the <a class="el" href="group___u_c_p___m_e_m.html#gacf61d6417524329d75f239d3f2ea8d3b">UCP Memory handle</a>, filled by <a class="el" href="group___u_c_p___m_e_m.html#ga080c10aaf347682594092d796bbc913f">ucp_mem_query</a> function.  <a href="group___u_c_p___m_e_m.html#structucp__mem__attr">More...</a><br /></td></tr>
<tr class="separator:structucp__mem__attr"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf20a30e6819c75f1a8a8727572661a99"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group___u_c_p___m_e_m.html#structucp__mem__map__params">ucp_mem_map_params</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___m_e_m.html#gaf20a30e6819c75f1a8a8727572661a99">ucp_mem_map_params_t</a></td></tr>
<tr class="memdesc:gaf20a30e6819c75f1a8a8727572661a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tuning parameters for the UCP memory mapping.  <a href="#gaf20a30e6819c75f1a8a8727572661a99">More...</a><br /></td></tr>
<tr class="separator:gaf20a30e6819c75f1a8a8727572661a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65ad5bf9d9e62766b5133fd80e3af613"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group___u_c_p___m_e_m.html#ga1a73c4a7fc1d8a6d75e6b53256eec0b8">ucp_mem_advice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___m_e_m.html#ga65ad5bf9d9e62766b5133fd80e3af613">ucp_mem_advice_t</a></td></tr>
<tr class="memdesc:ga65ad5bf9d9e62766b5133fd80e3af613"><td class="mdescLeft">&#160;</td><td class="mdescRight">list of UCP memory use advice.  <a href="#ga65ad5bf9d9e62766b5133fd80e3af613">More...</a><br /></td></tr>
<tr class="separator:ga65ad5bf9d9e62766b5133fd80e3af613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d5e3085cb8086de3592e15cc19a3b50"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group___u_c_p___m_e_m.html#structucp__mem__advise__params">ucp_mem_advise_params</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___m_e_m.html#ga6d5e3085cb8086de3592e15cc19a3b50">ucp_mem_advise_params_t</a></td></tr>
<tr class="memdesc:ga6d5e3085cb8086de3592e15cc19a3b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tuning parameters for the UCP memory advice.  <a href="#ga6d5e3085cb8086de3592e15cc19a3b50">More...</a><br /></td></tr>
<tr class="separator:ga6d5e3085cb8086de3592e15cc19a3b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa337a1ae88aed5f497d492d9406cf8c0"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group___u_c_p___m_e_m.html#structucp__memh__pack__params">ucp_memh_pack_params</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___m_e_m.html#gaa337a1ae88aed5f497d492d9406cf8c0">ucp_memh_pack_params_t</a></td></tr>
<tr class="memdesc:gaa337a1ae88aed5f497d492d9406cf8c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory handle pack parameters passed to <a class="el" href="group___u_c_p___m_e_m.html#ga8540eb3c5b885dfddbca0e39e00117ad">ucp_memh_pack</a>.  <a href="#gaa337a1ae88aed5f497d492d9406cf8c0">More...</a><br /></td></tr>
<tr class="separator:gaa337a1ae88aed5f497d492d9406cf8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eab5641bbc55da181862a06d4d79101"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group___u_c_p___m_e_m.html#structucp__memh__buffer__release__params">ucp_memh_buffer_release_params</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___m_e_m.html#ga0eab5641bbc55da181862a06d4d79101">ucp_memh_buffer_release_params_t</a></td></tr>
<tr class="memdesc:ga0eab5641bbc55da181862a06d4d79101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory handle release parameters passed to <a class="el" href="group___u_c_p___m_e_m.html#gab016c446e78e171c03a2fe11ab5fe48d">ucp_memh_buffer_release</a>.  <a href="#ga0eab5641bbc55da181862a06d4d79101">More...</a><br /></td></tr>
<tr class="separator:ga0eab5641bbc55da181862a06d4d79101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefeb4e775983f4313691a6b465e36c24"><td class="memItemLeft" align="right" valign="top">typedef struct ucp_rkey *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a></td></tr>
<tr class="memdesc:gaefeb4e775983f4313691a6b465e36c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP Remote memory handle.  <a href="#gaefeb4e775983f4313691a6b465e36c24">More...</a><br /></td></tr>
<tr class="separator:gaefeb4e775983f4313691a6b465e36c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf61d6417524329d75f239d3f2ea8d3b"><td class="memItemLeft" align="right" valign="top">typedef struct ucp_mem *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___m_e_m.html#gacf61d6417524329d75f239d3f2ea8d3b">ucp_mem_h</a></td></tr>
<tr class="memdesc:gacf61d6417524329d75f239d3f2ea8d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP Memory handle.  <a href="#gacf61d6417524329d75f239d3f2ea8d3b">More...</a><br /></td></tr>
<tr class="separator:gacf61d6417524329d75f239d3f2ea8d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80089f1bd72dea239fbcb45bd6414c26"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group___u_c_p___m_e_m.html#structucp__mem__attr">ucp_mem_attr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___m_e_m.html#ga80089f1bd72dea239fbcb45bd6414c26">ucp_mem_attr_t</a></td></tr>
<tr class="memdesc:ga80089f1bd72dea239fbcb45bd6414c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes of the <a class="el" href="group___u_c_p___m_e_m.html#gacf61d6417524329d75f239d3f2ea8d3b">UCP Memory handle</a>, filled by <a class="el" href="group___u_c_p___m_e_m.html#ga080c10aaf347682594092d796bbc913f">ucp_mem_query</a> function.  <a href="#ga80089f1bd72dea239fbcb45bd6414c26">More...</a><br /></td></tr>
<tr class="separator:ga80089f1bd72dea239fbcb45bd6414c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga1b78010c24c834aadc9fb8f1083e226f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___m_e_m.html#ga1b78010c24c834aadc9fb8f1083e226f">ucp_mem_map_params_field</a> { <br />
&#160;&#160;<a class="el" href="group___u_c_p___m_e_m.html#gga1b78010c24c834aadc9fb8f1083e226faa3ddd6c11c7610ae3c97fcb4473d9332">UCP_MEM_MAP_PARAM_FIELD_ADDRESS</a> = UCS_BIT(0), 
<a class="el" href="group___u_c_p___m_e_m.html#gga1b78010c24c834aadc9fb8f1083e226faa4aa7e36cd51262837f9179cb74fb22a">UCP_MEM_MAP_PARAM_FIELD_LENGTH</a> = UCS_BIT(1), 
<a class="el" href="group___u_c_p___m_e_m.html#gga1b78010c24c834aadc9fb8f1083e226fafc2e699ec811b6848bfc40d4a6c1b049">UCP_MEM_MAP_PARAM_FIELD_FLAGS</a> = UCS_BIT(2), 
<a class="el" href="group___u_c_p___m_e_m.html#gga1b78010c24c834aadc9fb8f1083e226fa349ca907322a708479795afef1fe28ff">UCP_MEM_MAP_PARAM_FIELD_PROT</a> = UCS_BIT(3), 
<br />
&#160;&#160;<a class="el" href="group___u_c_p___m_e_m.html#gga1b78010c24c834aadc9fb8f1083e226fab5d6cd1e76f334a4ae5d10d5955d51b7">UCP_MEM_MAP_PARAM_FIELD_MEMORY_TYPE</a> = UCS_BIT(4), 
<a class="el" href="group___u_c_p___m_e_m.html#gga1b78010c24c834aadc9fb8f1083e226faf130e704ffef248e615f5aeb25208ce9">UCP_MEM_MAP_PARAM_FIELD_EXPORTED_MEMH_BUFFER</a> = UCS_BIT(5)
<br />
 }<tr class="memdesc:ga1b78010c24c834aadc9fb8f1083e226f"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP memory mapping parameters field mask.  <a href="group___u_c_p___m_e_m.html#ga1b78010c24c834aadc9fb8f1083e226f">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga1b78010c24c834aadc9fb8f1083e226f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c0f7ca217c77fa0ae8649e21b24a1fc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___m_e_m.html#ga3c0f7ca217c77fa0ae8649e21b24a1fc">ucp_mem_advise_params_field</a> { <a class="el" href="group___u_c_p___m_e_m.html#gga3c0f7ca217c77fa0ae8649e21b24a1fca19cd431b1a46a62abaf904d0358ffaad">UCP_MEM_ADVISE_PARAM_FIELD_ADDRESS</a> = UCS_BIT(0), 
<a class="el" href="group___u_c_p___m_e_m.html#gga3c0f7ca217c77fa0ae8649e21b24a1fcac60bdd12018a716587c71883ae408b60">UCP_MEM_ADVISE_PARAM_FIELD_LENGTH</a> = UCS_BIT(1), 
<a class="el" href="group___u_c_p___m_e_m.html#gga3c0f7ca217c77fa0ae8649e21b24a1fca8834ee80833e5509eea118807dc1a213">UCP_MEM_ADVISE_PARAM_FIELD_ADVICE</a> = UCS_BIT(2)
 }<tr class="memdesc:ga3c0f7ca217c77fa0ae8649e21b24a1fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP memory advice parameters field mask.  <a href="group___u_c_p___m_e_m.html#ga3c0f7ca217c77fa0ae8649e21b24a1fc">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga3c0f7ca217c77fa0ae8649e21b24a1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06fc87d81c62e9abb8790b6e5713c55b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="group___u_c_p___m_e_m.html#gga06fc87d81c62e9abb8790b6e5713c55ba31fa3f795110becccb25734067b5e203">UCP_MEM_MAP_NONBLOCK</a> = UCS_BIT(0), 
<a class="el" href="group___u_c_p___m_e_m.html#gga06fc87d81c62e9abb8790b6e5713c55ba8cb2c18c15da7e8da9aa2de5b407957a">UCP_MEM_MAP_ALLOCATE</a> = UCS_BIT(1), 
<a class="el" href="group___u_c_p___m_e_m.html#gga06fc87d81c62e9abb8790b6e5713c55ba937051276d5a7825211189c84d7f2922">UCP_MEM_MAP_FIXED</a> = UCS_BIT(2)
 }<tr class="memdesc:ga06fc87d81c62e9abb8790b6e5713c55b"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP memory mapping flags.  <a href="group___u_c_p___m_e_m.html#ga06fc87d81c62e9abb8790b6e5713c55b">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga06fc87d81c62e9abb8790b6e5713c55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf764cbdea00d65edcd07bb9953ad2b7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="group___u_c_p___m_e_m.html#ggadf764cbdea00d65edcd07bb9953ad2b7a78c92c33fb131e7084b6a2933632ec17">UCP_MEM_MAP_PROT_LOCAL_READ</a> = UCS_BIT(0), 
<a class="el" href="group___u_c_p___m_e_m.html#ggadf764cbdea00d65edcd07bb9953ad2b7a6961fd2dcb7ff1fd5980f2d09bb40c39">UCP_MEM_MAP_PROT_LOCAL_WRITE</a> = UCS_BIT(1), 
<a class="el" href="group___u_c_p___m_e_m.html#ggadf764cbdea00d65edcd07bb9953ad2b7a2dc03b7f80ce18c5ec948d1039342bdb">UCP_MEM_MAP_PROT_REMOTE_READ</a> = UCS_BIT(8), 
<a class="el" href="group___u_c_p___m_e_m.html#ggadf764cbdea00d65edcd07bb9953ad2b7a4d1429c096e17c691ca710aeb6385fe8">UCP_MEM_MAP_PROT_REMOTE_WRITE</a> = UCS_BIT(9)
 }<tr class="memdesc:gadf764cbdea00d65edcd07bb9953ad2b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP memory mapping protection mode.  <a href="group___u_c_p___m_e_m.html#gadf764cbdea00d65edcd07bb9953ad2b7">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gadf764cbdea00d65edcd07bb9953ad2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a73c4a7fc1d8a6d75e6b53256eec0b8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___m_e_m.html#ga1a73c4a7fc1d8a6d75e6b53256eec0b8">ucp_mem_advice</a> { <a class="el" href="group___u_c_p___m_e_m.html#gga1a73c4a7fc1d8a6d75e6b53256eec0b8a3a335aa51dc934e57f4ccbd26fb32fb0">UCP_MADV_NORMAL</a> = 0, 
<a class="el" href="group___u_c_p___m_e_m.html#gga1a73c4a7fc1d8a6d75e6b53256eec0b8a882711eaac0fe1172570783e9824e12f">UCP_MADV_WILLNEED</a>
 }<tr class="memdesc:ga1a73c4a7fc1d8a6d75e6b53256eec0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">list of UCP memory use advice.  <a href="group___u_c_p___m_e_m.html#ga1a73c4a7fc1d8a6d75e6b53256eec0b8">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga1a73c4a7fc1d8a6d75e6b53256eec0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9143b85c7c40d6b13020a13bc13f9dbf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___m_e_m.html#ga9143b85c7c40d6b13020a13bc13f9dbf">ucp_memh_pack_params_field</a> { <a class="el" href="group___u_c_p___m_e_m.html#gga9143b85c7c40d6b13020a13bc13f9dbfaa88937590bafafda1088444634173fa8">UCP_MEMH_PACK_PARAM_FIELD_FLAGS</a> = UCS_BIT(0)
 }<tr class="memdesc:ga9143b85c7c40d6b13020a13bc13f9dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP memory handle packing parameters field mask.  <a href="group___u_c_p___m_e_m.html#ga9143b85c7c40d6b13020a13bc13f9dbf">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga9143b85c7c40d6b13020a13bc13f9dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83ac2dbb4fe6b93948b00c9a2ad16efe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___m_e_m.html#ga83ac2dbb4fe6b93948b00c9a2ad16efe">ucp_memh_pack_flags</a> { <a class="el" href="group___u_c_p___m_e_m.html#gga83ac2dbb4fe6b93948b00c9a2ad16efead1933cc321da0f7ab0428070d36d1e00">UCP_MEMH_PACK_FLAG_EXPORT</a> = UCS_BIT(0)
 }<tr class="memdesc:ga83ac2dbb4fe6b93948b00c9a2ad16efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP memory handle flags.  <a href="group___u_c_p___m_e_m.html#ga83ac2dbb4fe6b93948b00c9a2ad16efe">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga83ac2dbb4fe6b93948b00c9a2ad16efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0d7a54391c964c59b2cfbf30e23dc14"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___m_e_m.html#gab0d7a54391c964c59b2cfbf30e23dc14">ucp_mem_attr_field</a> { <a class="el" href="group___u_c_p___m_e_m.html#ggab0d7a54391c964c59b2cfbf30e23dc14a7255d71b73495f3466b2b3938f85630f">UCP_MEM_ATTR_FIELD_ADDRESS</a> = UCS_BIT(0), 
<a class="el" href="group___u_c_p___m_e_m.html#ggab0d7a54391c964c59b2cfbf30e23dc14aaf7684459badd65a4e70a65813ae1e35">UCP_MEM_ATTR_FIELD_LENGTH</a> = UCS_BIT(1), 
<a class="el" href="group___u_c_p___m_e_m.html#ggab0d7a54391c964c59b2cfbf30e23dc14a97c63bcd6332d0556e4439bc65531116">UCP_MEM_ATTR_FIELD_MEM_TYPE</a> = UCS_BIT(2)
 }<tr class="memdesc:gab0d7a54391c964c59b2cfbf30e23dc14"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP Memory handle attributes field mask.  <a href="group___u_c_p___m_e_m.html#gab0d7a54391c964c59b2cfbf30e23dc14">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gab0d7a54391c964c59b2cfbf30e23dc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1af508a609cc7f2cebf4b33f9ee6ac66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___m_e_m.html#ga1af508a609cc7f2cebf4b33f9ee6ac66">ucp_mem_map</a> (<a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga0e40ddc46f0bbe868a13f6ab1b674f76">ucp_context_h</a> context, const <a class="el" href="group___u_c_p___m_e_m.html#gaf20a30e6819c75f1a8a8727572661a99">ucp_mem_map_params_t</a> *params, <a class="el" href="group___u_c_p___m_e_m.html#gacf61d6417524329d75f239d3f2ea8d3b">ucp_mem_h</a> *memh_p)</td></tr>
<tr class="memdesc:ga1af508a609cc7f2cebf4b33f9ee6ac66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map or allocate memory for zero-copy operations.  <a href="#ga1af508a609cc7f2cebf4b33f9ee6ac66">More...</a><br /></td></tr>
<tr class="separator:ga1af508a609cc7f2cebf4b33f9ee6ac66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8bd616375fe05594690b5e0cddd6318"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___m_e_m.html#gac8bd616375fe05594690b5e0cddd6318">ucp_mem_unmap</a> (<a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga0e40ddc46f0bbe868a13f6ab1b674f76">ucp_context_h</a> context, <a class="el" href="group___u_c_p___m_e_m.html#gacf61d6417524329d75f239d3f2ea8d3b">ucp_mem_h</a> memh)</td></tr>
<tr class="memdesc:gac8bd616375fe05594690b5e0cddd6318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmap memory segment.  <a href="#gac8bd616375fe05594690b5e0cddd6318">More...</a><br /></td></tr>
<tr class="separator:gac8bd616375fe05594690b5e0cddd6318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga080c10aaf347682594092d796bbc913f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___m_e_m.html#ga080c10aaf347682594092d796bbc913f">ucp_mem_query</a> (const <a class="el" href="group___u_c_p___m_e_m.html#gacf61d6417524329d75f239d3f2ea8d3b">ucp_mem_h</a> memh, <a class="el" href="group___u_c_p___m_e_m.html#ga80089f1bd72dea239fbcb45bd6414c26">ucp_mem_attr_t</a> *attr)</td></tr>
<tr class="memdesc:ga080c10aaf347682594092d796bbc913f"><td class="mdescLeft">&#160;</td><td class="mdescRight">query mapped memory segment  <a href="#ga080c10aaf347682594092d796bbc913f">More...</a><br /></td></tr>
<tr class="separator:ga080c10aaf347682594092d796bbc913f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3240a60d906b2ecf5d0a19acdf13850f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___m_e_m.html#ga3240a60d906b2ecf5d0a19acdf13850f">ucp_mem_print_info</a> (const char *mem_spec, <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga0e40ddc46f0bbe868a13f6ab1b674f76">ucp_context_h</a> context, FILE *stream)</td></tr>
<tr class="memdesc:ga3240a60d906b2ecf5d0a19acdf13850f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print memory mapping information.  <a href="#ga3240a60d906b2ecf5d0a19acdf13850f">More...</a><br /></td></tr>
<tr class="separator:ga3240a60d906b2ecf5d0a19acdf13850f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga455313831b8734fe1a824109c3ffc588"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___m_e_m.html#ga455313831b8734fe1a824109c3ffc588">ucp_mem_advise</a> (<a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga0e40ddc46f0bbe868a13f6ab1b674f76">ucp_context_h</a> context, <a class="el" href="group___u_c_p___m_e_m.html#gacf61d6417524329d75f239d3f2ea8d3b">ucp_mem_h</a> memh, <a class="el" href="group___u_c_p___m_e_m.html#ga6d5e3085cb8086de3592e15cc19a3b50">ucp_mem_advise_params_t</a> *params)</td></tr>
<tr class="memdesc:ga455313831b8734fe1a824109c3ffc588"><td class="mdescLeft">&#160;</td><td class="mdescRight">give advice about the use of memory  <a href="#ga455313831b8734fe1a824109c3ffc588">More...</a><br /></td></tr>
<tr class="separator:ga455313831b8734fe1a824109c3ffc588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8540eb3c5b885dfddbca0e39e00117ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___m_e_m.html#ga8540eb3c5b885dfddbca0e39e00117ad">ucp_memh_pack</a> (<a class="el" href="group___u_c_p___m_e_m.html#gacf61d6417524329d75f239d3f2ea8d3b">ucp_mem_h</a> memh, const <a class="el" href="group___u_c_p___m_e_m.html#gaa337a1ae88aed5f497d492d9406cf8c0">ucp_memh_pack_params_t</a> *params, void **buffer_p, size_t *buffer_size_p)</td></tr>
<tr class="memdesc:ga8540eb3c5b885dfddbca0e39e00117ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a memory handle to a buffer specified by the user.  <a href="#ga8540eb3c5b885dfddbca0e39e00117ad">More...</a><br /></td></tr>
<tr class="separator:ga8540eb3c5b885dfddbca0e39e00117ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab016c446e78e171c03a2fe11ab5fe48d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___m_e_m.html#gab016c446e78e171c03a2fe11ab5fe48d">ucp_memh_buffer_release</a> (void *buffer, const <a class="el" href="group___u_c_p___m_e_m.html#ga0eab5641bbc55da181862a06d4d79101">ucp_memh_buffer_release_params_t</a> *params)</td></tr>
<tr class="memdesc:gab016c446e78e171c03a2fe11ab5fe48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release packed memory handle buffer.  <a href="#gab016c446e78e171c03a2fe11ab5fe48d">More...</a><br /></td></tr>
<tr class="separator:gab016c446e78e171c03a2fe11ab5fe48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92353d1cb038a4e281f0a1973937079d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___m_e_m.html#ga92353d1cb038a4e281f0a1973937079d">ucp_ep_rkey_unpack</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, const void *rkey_buffer, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> *rkey_p)</td></tr>
<tr class="memdesc:ga92353d1cb038a4e281f0a1973937079d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create remote access key from packed buffer.  <a href="#ga92353d1cb038a4e281f0a1973937079d">More...</a><br /></td></tr>
<tr class="separator:ga92353d1cb038a4e281f0a1973937079d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68f3458805ba15d6a5883219ecd56c1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___m_e_m.html#ga68f3458805ba15d6a5883219ecd56c1e">ucp_rkey_ptr</a> (<a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey, uint64_t raddr, void **addr_p)</td></tr>
<tr class="memdesc:ga68f3458805ba15d6a5883219ecd56c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a local pointer to remote memory.  <a href="#ga68f3458805ba15d6a5883219ecd56c1e">More...</a><br /></td></tr>
<tr class="separator:ga68f3458805ba15d6a5883219ecd56c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae33d7cc264e0fe1b11e27ae4289fba39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___m_e_m.html#gae33d7cc264e0fe1b11e27ae4289fba39">ucp_rkey_destroy</a> (<a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey)</td></tr>
<tr class="memdesc:gae33d7cc264e0fe1b11e27ae4289fba39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the remote key.  <a href="#gae33d7cc264e0fe1b11e27ae4289fba39">More...</a><br /></td></tr>
<tr class="separator:gae33d7cc264e0fe1b11e27ae4289fba39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbb6b3ace4ab988cd7660319123407b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___m_e_m.html#gadbb6b3ace4ab988cd7660319123407b4">ucp_rkey_pack</a> (<a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga0e40ddc46f0bbe868a13f6ab1b674f76">ucp_context_h</a> context, <a class="el" href="group___u_c_p___m_e_m.html#gacf61d6417524329d75f239d3f2ea8d3b">ucp_mem_h</a> memh, void **rkey_buffer_p, size_t *size_p)</td></tr>
<tr class="memdesc:gadbb6b3ace4ab988cd7660319123407b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack memory region remote access key.  <a href="#gadbb6b3ace4ab988cd7660319123407b4">More...</a><br /></td></tr>
<tr class="separator:gadbb6b3ace4ab988cd7660319123407b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bc005f53da015f4a062087e6eb064e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___m_e_m.html#ga8bc005f53da015f4a062087e6eb064e9">ucp_rkey_buffer_release</a> (void *rkey_buffer)</td></tr>
<tr class="memdesc:ga8bc005f53da015f4a062087e6eb064e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release packed remote key buffer.  <a href="#ga8bc005f53da015f4a062087e6eb064e9">More...</a><br /></td></tr>
<tr class="separator:ga8bc005f53da015f4a062087e6eb064e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>UCP Memory routines </p>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structucp__mem__map__params" id="structucp__mem__map__params"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ucp_mem_map_params</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>The structure defines the parameters that are used for the UCP memory mapping tuning during the <a class="el" href="group___u_c_p___m_e_m.html#ga1af508a609cc7f2cebf4b33f9ee6ac66">ucp_mem_map</a> routine. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aaeaeceb96d57c6cd5048abeda3fcb87f"></a>uint64_t</td>
<td class="fieldname">
field_mask</td>
<td class="fielddoc">
<p>Mask of valid fields in this structure, using bits from <a class="el" href="group___u_c_p___m_e_m.html#ga1b78010c24c834aadc9fb8f1083e226f">ucp_mem_map_params_field</a>. Fields not specified in this mask will be ignored. Provides ABI compatibility with respect to adding new fields. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="acc3761c4bbcca9c1defa742a8db08bbb"></a>void *</td>
<td class="fieldname">
address</td>
<td class="fielddoc">
<p>If the address is not NULL, the routine maps (registers) the memory segment pointed to by this address. If the pointer is NULL, the library allocates mapped (registered) memory segment and returns its address in this argument. Therefore, this value is optional. If it's not set (along with its corresponding bit in the field_mask - <a class="el" href="group___u_c_p___m_e_m.html#gga1b78010c24c834aadc9fb8f1083e226faa3ddd6c11c7610ae3c97fcb4473d9332">UCP_MEM_MAP_PARAM_FIELD_ADDRESS</a>), the ucp_mem_map routine will consider address as set to NULL and will allocate memory. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a36d735fe974dd85677474c028edb2af8"></a>size_t</td>
<td class="fieldname">
length</td>
<td class="fielddoc">
<p>Length (in bytes) to allocate or map (register). This field is mandatory for filling (along with its corresponding bit in the field_mask - <a class="el" href="group___u_c_p___m_e_m.html#gga1b78010c24c834aadc9fb8f1083e226faa4aa7e36cd51262837f9179cb74fb22a">UCP_MEM_MAP_PARAM_FIELD_LENGTH</a>). The <a class="el" href="group___u_c_p___m_e_m.html#ga1af508a609cc7f2cebf4b33f9ee6ac66">ucp_mem_map</a> routine will return with an error if the length isn't specified. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a668567560d65f2e0458159d444fb89ca"></a>unsigned</td>
<td class="fieldname">
flags</td>
<td class="fielddoc">
<p>Allocation flags, e.g. <a class="el" href="group___u_c_p___m_e_m.html#gga06fc87d81c62e9abb8790b6e5713c55ba31fa3f795110becccb25734067b5e203">UCP_MEM_MAP_NONBLOCK</a>. This value is optional. If it's not set (along with its corresponding bit in the field_mask - <a class="el" href="group___u_c_p___m_e_m.html#gga1b78010c24c834aadc9fb8f1083e226fafc2e699ec811b6848bfc40d4a6c1b049">UCP_MEM_MAP_PARAM_FIELD_FLAGS</a>), the <a class="el" href="group___u_c_p___m_e_m.html#ga1af508a609cc7f2cebf4b33f9ee6ac66">ucp_mem_map</a> routine will consider the flags as set to zero. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="af8bb06187e2c1f180a24d867a4922b2e"></a>unsigned</td>
<td class="fieldname">
prot</td>
<td class="fielddoc">
<p>Memory protection mode, e.g. <a class="el" href="group___u_c_p___m_e_m.html#ggadf764cbdea00d65edcd07bb9953ad2b7a78c92c33fb131e7084b6a2933632ec17">UCP_MEM_MAP_PROT_LOCAL_READ</a>. This value is optional. If it's not set, the <a class="el" href="group___u_c_p___m_e_m.html#ga1af508a609cc7f2cebf4b33f9ee6ac66">ucp_mem_map</a> routine will consider the flags as set to UCP_MEM_MAP_PROT_LOCAL_READ|UCP_MEM_MAP_PROT_LOCAL_WRITE| UCP_MEM_MAP_PROT_REMOTE_READ|UCP_MEM_MAP_PROT_REMOTE_WRITE. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a71916e12e0fa7706355965de2edd7fc9"></a><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf9af40bd8efcc0aac27a5194deeb1fbf">ucs_memory_type_t</a></td>
<td class="fieldname">
memory_type</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="af4b12bd23e90295c7503e6dc19063a6b"></a>const void *</td>
<td class="fieldname">
exported_memh_buffer</td>
<td class="fielddoc">
<p>Exported memory handle buffer as returned by <a class="el" href="group___u_c_p___m_e_m.html#ga1af508a609cc7f2cebf4b33f9ee6ac66">ucp_mem_map</a> function for a memory handle created and packed by <a class="el" href="group___u_c_p___m_e_m.html#ga8540eb3c5b885dfddbca0e39e00117ad">ucp_memh_pack</a> with <a class="el" href="group___u_c_p___m_e_m.html#gga83ac2dbb4fe6b93948b00c9a2ad16efead1933cc321da0f7ab0428070d36d1e00">UCP_MEMH_PACK_FLAG_EXPORT</a> flag. If this field is specified for <a class="el" href="group___u_c_p___m_e_m.html#ga1af508a609cc7f2cebf4b33f9ee6ac66">ucp_mem_map</a> function, a resulting memory handle will be a mapping of peer memory instead of local memory. If the field is not set (along with its corresponding bit in the field_mask - <a class="el" href="group___u_c_p___m_e_m.html#gga1b78010c24c834aadc9fb8f1083e226faf130e704ffef248e615f5aeb25208ce9">UCP_MEM_MAP_PARAM_FIELD_EXPORTED_MEMH_BUFFER</a>), the <a class="el" href="group___u_c_p___m_e_m.html#ga1af508a609cc7f2cebf4b33f9ee6ac66">ucp_mem_map</a> routine will consider the memory handle buffer to be set to NULL by default. </p>
</td></tr>
</table>

</div>
</div>
<a name="structucp__mem__advise__params" id="structucp__mem__advise__params"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ucp_mem_advise_params</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This structure defines the parameters that are used for the UCP memory advice tuning during the <a class="el" href="group___u_c_p___m_e_m.html#ga455313831b8734fe1a824109c3ffc588">ucp_mem_advise</a> routine. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a01c09d6fdafcd62e733cece26166e036"></a>uint64_t</td>
<td class="fieldname">
field_mask</td>
<td class="fielddoc">
<p>Mask of valid fields in this structure, using bits from <a class="el" href="group___u_c_p___m_e_m.html#ga3c0f7ca217c77fa0ae8649e21b24a1fc">ucp_mem_advise_params_field</a>. All fields are mandatory. Provides ABI compatibility with respect to adding new fields. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ab25f1b439c184a0bfb93eda0c9ceb9f7"></a>void *</td>
<td class="fieldname">
address</td>
<td class="fielddoc">
<p>Memory base address. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a33e763e90d0cc7aad526a69dee8ef900"></a>size_t</td>
<td class="fieldname">
length</td>
<td class="fielddoc">
<p>Length (in bytes) to allocate or map (register). </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a26833bd101fcb6b4c1024b2975aed5dc"></a><a class="el" href="group___u_c_p___m_e_m.html#ga65ad5bf9d9e62766b5133fd80e3af613">ucp_mem_advice_t</a></td>
<td class="fieldname">
advice</td>
<td class="fielddoc">
<p>Memory use advice <a class="el" href="group___u_c_p___m_e_m.html#ga1a73c4a7fc1d8a6d75e6b53256eec0b8">ucp_mem_advice</a> </p>
</td></tr>
</table>

</div>
</div>
<a name="structucp__memh__pack__params" id="structucp__memh__pack__params"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ucp_memh_pack_params</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This structure defines the parameters that are used for packing the UCP memory handle during the <a class="el" href="group___u_c_p___m_e_m.html#ga8540eb3c5b885dfddbca0e39e00117ad">ucp_memh_pack</a> routine. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aafd1c1f51c5170b30695d9f73aad1f99"></a>uint64_t</td>
<td class="fieldname">
field_mask</td>
<td class="fielddoc">
<p>Mask of valid fields in this structure. Fields not specified in this mask will be ignored. Provides ABI compatibility with respect to adding new fields. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a3e9ba8e33dd1daf74e341dee2abacff7"></a>uint64_t</td>
<td class="fieldname">
flags</td>
<td class="fielddoc">
<p>Flags to control packing of a memory handle. </p>
</td></tr>
</table>

</div>
</div>
<a name="structucp__memh__buffer__release__params" id="structucp__memh__buffer__release__params"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ucp_memh_buffer_release_params</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This structure defines the parameters that are used for releasing the UCP memory handle buffer during the <a class="el" href="group___u_c_p___m_e_m.html#gab016c446e78e171c03a2fe11ab5fe48d">ucp_memh_buffer_release</a> routine. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a29dab951ef791f596be6a08e7fc88cb6"></a>uint64_t</td>
<td class="fieldname">
field_mask</td>
<td class="fielddoc">
<p>Mask of valid fields in this structure. All fields are mandatory. Provides ABI compatibility with respect to adding new fields. </p>
</td></tr>
</table>

</div>
</div>
<a name="structucp__mem__attr" id="structucp__mem__attr"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ucp_mem_attr</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ac2b9b68d716c78b3750f50f599259e66"></a>uint64_t</td>
<td class="fieldname">
field_mask</td>
<td class="fielddoc">
<p>Mask of valid fields in this structure, using bits from <a class="el" href="group___u_c_p___m_e_m.html#gab0d7a54391c964c59b2cfbf30e23dc14">ucp_mem_attr_field</a>. Fields not specified in this mask will be ignored. Provides ABI compatibility with respect to adding new fields. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ab9a2b772838f436158ae4e25d8bb21e4"></a>void *</td>
<td class="fieldname">
address</td>
<td class="fielddoc">
<p>Address of the memory segment. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ae807002e05a4a269a74c767e23f49fa8"></a>size_t</td>
<td class="fieldname">
length</td>
<td class="fielddoc">
<p>Size of the memory segment. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ac88b3fb764dd2af1a77bbe90161b2896"></a><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf9af40bd8efcc0aac27a5194deeb1fbf">ucs_memory_type_t</a></td>
<td class="fieldname">
mem_type</td>
<td class="fielddoc">
<p>Type of allocated or registered memory </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gaf20a30e6819c75f1a8a8727572661a99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group___u_c_p___m_e_m.html#structucp__mem__map__params">ucp_mem_map_params</a>  <a class="el" href="group___u_c_p___m_e_m.html#gaf20a30e6819c75f1a8a8727572661a99">ucp_mem_map_params_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The structure defines the parameters that are used for the UCP memory mapping tuning during the <a class="el" href="group___u_c_p___m_e_m.html#ga1af508a609cc7f2cebf4b33f9ee6ac66">ucp_mem_map</a> routine. </p>

</div>
</div>
<a class="anchor" id="ga65ad5bf9d9e62766b5133fd80e3af613"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___u_c_p___m_e_m.html#ga1a73c4a7fc1d8a6d75e6b53256eec0b8">ucp_mem_advice</a>  <a class="el" href="group___u_c_p___m_e_m.html#ga65ad5bf9d9e62766b5133fd80e3af613">ucp_mem_advice_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The enumeration list describes memory advice supported by <a class="el" href="group___u_c_p___m_e_m.html#ga455313831b8734fe1a824109c3ffc588">ucp_mem_advise()</a> function. </p>

</div>
</div>
<a class="anchor" id="ga6d5e3085cb8086de3592e15cc19a3b50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group___u_c_p___m_e_m.html#structucp__mem__advise__params">ucp_mem_advise_params</a>  <a class="el" href="group___u_c_p___m_e_m.html#ga6d5e3085cb8086de3592e15cc19a3b50">ucp_mem_advise_params_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This structure defines the parameters that are used for the UCP memory advice tuning during the <a class="el" href="group___u_c_p___m_e_m.html#ga455313831b8734fe1a824109c3ffc588">ucp_mem_advise</a> routine. </p>

</div>
</div>
<a class="anchor" id="gaa337a1ae88aed5f497d492d9406cf8c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group___u_c_p___m_e_m.html#structucp__memh__pack__params">ucp_memh_pack_params</a>  <a class="el" href="group___u_c_p___m_e_m.html#gaa337a1ae88aed5f497d492d9406cf8c0">ucp_memh_pack_params_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This structure defines the parameters that are used for packing the UCP memory handle during the <a class="el" href="group___u_c_p___m_e_m.html#ga8540eb3c5b885dfddbca0e39e00117ad">ucp_memh_pack</a> routine. </p>

</div>
</div>
<a class="anchor" id="ga0eab5641bbc55da181862a06d4d79101"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group___u_c_p___m_e_m.html#structucp__memh__buffer__release__params">ucp_memh_buffer_release_params</a>  <a class="el" href="group___u_c_p___m_e_m.html#ga0eab5641bbc55da181862a06d4d79101">ucp_memh_buffer_release_params_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This structure defines the parameters that are used for releasing the UCP memory handle buffer during the <a class="el" href="group___u_c_p___m_e_m.html#gab016c446e78e171c03a2fe11ab5fe48d">ucp_memh_buffer_release</a> routine. </p>

</div>
</div>
<a class="anchor" id="gaefeb4e775983f4313691a6b465e36c24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct ucp_rkey* <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remote memory handle is an opaque object representing remote memory access information. Typically, the handle includes a memory access key and other network hardware specific information, which are input to remote memory access operations, such as PUT, GET, and ATOMIC. The object is communicated to remote peers to enable an access to the memory region. </p>

</div>
</div>
<a class="anchor" id="gacf61d6417524329d75f239d3f2ea8d3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct ucp_mem* <a class="el" href="group___u_c_p___m_e_m.html#gacf61d6417524329d75f239d3f2ea8d3b">ucp_mem_h</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Memory handle is an opaque object representing a memory region allocated through UCP library, which is optimized for remote memory access operations (zero-copy operations). The memory handle is a self-contained object, which includes the information required to access the memory region locally, while <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote key</a> is used to access it remotely. The memory could be registered to one or multiple network resources that are supported by UCP, such as InfiniBand, Gemini, and others. </p>

</div>
</div>
<a class="anchor" id="ga80089f1bd72dea239fbcb45bd6414c26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group___u_c_p___m_e_m.html#structucp__mem__attr">ucp_mem_attr</a>  <a class="el" href="group___u_c_p___m_e_m.html#ga80089f1bd72dea239fbcb45bd6414c26">ucp_mem_attr_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga1b78010c24c834aadc9fb8f1083e226f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_c_p___m_e_m.html#ga1b78010c24c834aadc9fb8f1083e226f">ucp_mem_map_params_field</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The enumeration allows specifying which fields in <a class="el" href="group___u_c_p___m_e_m.html#gaf20a30e6819c75f1a8a8727572661a99">ucp_mem_map_params_t</a> are present. It is used to enable backward compatibility support. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga1b78010c24c834aadc9fb8f1083e226faa3ddd6c11c7610ae3c97fcb4473d9332"></a>UCP_MEM_MAP_PARAM_FIELD_ADDRESS&#160;</td><td class="fielddoc">
<p>Address of the memory that will be used in the <a class="el" href="group___u_c_p___m_e_m.html#ga1af508a609cc7f2cebf4b33f9ee6ac66">ucp_mem_map</a> routine. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1b78010c24c834aadc9fb8f1083e226faa4aa7e36cd51262837f9179cb74fb22a"></a>UCP_MEM_MAP_PARAM_FIELD_LENGTH&#160;</td><td class="fielddoc">
<p>The size of memory that will be allocated or registered in the <a class="el" href="group___u_c_p___m_e_m.html#ga1af508a609cc7f2cebf4b33f9ee6ac66">ucp_mem_map</a> routine. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1b78010c24c834aadc9fb8f1083e226fafc2e699ec811b6848bfc40d4a6c1b049"></a>UCP_MEM_MAP_PARAM_FIELD_FLAGS&#160;</td><td class="fielddoc">
<p>Allocation flags. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1b78010c24c834aadc9fb8f1083e226fa349ca907322a708479795afef1fe28ff"></a>UCP_MEM_MAP_PARAM_FIELD_PROT&#160;</td><td class="fielddoc">
<p>Memory protection mode. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1b78010c24c834aadc9fb8f1083e226fab5d6cd1e76f334a4ae5d10d5955d51b7"></a>UCP_MEM_MAP_PARAM_FIELD_MEMORY_TYPE&#160;</td><td class="fielddoc">
<p>Memory type. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1b78010c24c834aadc9fb8f1083e226faf130e704ffef248e615f5aeb25208ce9"></a>UCP_MEM_MAP_PARAM_FIELD_EXPORTED_MEMH_BUFFER&#160;</td><td class="fielddoc">
<p>Exported memory handle buffer. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga3c0f7ca217c77fa0ae8649e21b24a1fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_c_p___m_e_m.html#ga3c0f7ca217c77fa0ae8649e21b24a1fc">ucp_mem_advise_params_field</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The enumeration allows specifying which fields in <a class="el" href="group___u_c_p___m_e_m.html#ga6d5e3085cb8086de3592e15cc19a3b50">ucp_mem_advise_params_t</a> are present. It is used to enable backward compatibility support. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga3c0f7ca217c77fa0ae8649e21b24a1fca19cd431b1a46a62abaf904d0358ffaad"></a>UCP_MEM_ADVISE_PARAM_FIELD_ADDRESS&#160;</td><td class="fielddoc">
<p>Address of the memory </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga3c0f7ca217c77fa0ae8649e21b24a1fcac60bdd12018a716587c71883ae408b60"></a>UCP_MEM_ADVISE_PARAM_FIELD_LENGTH&#160;</td><td class="fielddoc">
<p>The size of memory </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga3c0f7ca217c77fa0ae8649e21b24a1fca8834ee80833e5509eea118807dc1a213"></a>UCP_MEM_ADVISE_PARAM_FIELD_ADVICE&#160;</td><td class="fielddoc">
<p>Advice on memory usage </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga06fc87d81c62e9abb8790b6e5713c55b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The enumeration list describes the memory mapping flags supported by <a class="el" href="group___u_c_p___m_e_m.html#ga1af508a609cc7f2cebf4b33f9ee6ac66">ucp_mem_map()</a> function. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga06fc87d81c62e9abb8790b6e5713c55ba31fa3f795110becccb25734067b5e203"></a>UCP_MEM_MAP_NONBLOCK&#160;</td><td class="fielddoc">
<p>Complete the mapping faster, possibly by not populating the pages in the mapping up-front, and mapping them later when they are accessed by communication routines. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga06fc87d81c62e9abb8790b6e5713c55ba8cb2c18c15da7e8da9aa2de5b407957a"></a>UCP_MEM_MAP_ALLOCATE&#160;</td><td class="fielddoc">
<p>Identify requirement for allocation, if passed address is not a null-pointer, then it will be used as a hint or direct address for allocation. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga06fc87d81c62e9abb8790b6e5713c55ba937051276d5a7825211189c84d7f2922"></a>UCP_MEM_MAP_FIXED&#160;</td><td class="fielddoc">
<p>Don't interpret address as a hint: place the mapping at exactly that address. The address must be a multiple of the page size. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gadf764cbdea00d65edcd07bb9953ad2b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The enumeration list describes the memory mapping protections supported by the <a class="el" href="group___u_c_p___m_e_m.html#ga1af508a609cc7f2cebf4b33f9ee6ac66">ucp_mem_map()</a> function. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggadf764cbdea00d65edcd07bb9953ad2b7a78c92c33fb131e7084b6a2933632ec17"></a>UCP_MEM_MAP_PROT_LOCAL_READ&#160;</td><td class="fielddoc">
<p>Enable local read access. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggadf764cbdea00d65edcd07bb9953ad2b7a6961fd2dcb7ff1fd5980f2d09bb40c39"></a>UCP_MEM_MAP_PROT_LOCAL_WRITE&#160;</td><td class="fielddoc">
<p>Enable local write access. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggadf764cbdea00d65edcd07bb9953ad2b7a2dc03b7f80ce18c5ec948d1039342bdb"></a>UCP_MEM_MAP_PROT_REMOTE_READ&#160;</td><td class="fielddoc">
<p>Enable remote read access. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggadf764cbdea00d65edcd07bb9953ad2b7a4d1429c096e17c691ca710aeb6385fe8"></a>UCP_MEM_MAP_PROT_REMOTE_WRITE&#160;</td><td class="fielddoc">
<p>Enable remote write access. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga1a73c4a7fc1d8a6d75e6b53256eec0b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_c_p___m_e_m.html#ga1a73c4a7fc1d8a6d75e6b53256eec0b8">ucp_mem_advice</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The enumeration list describes memory advice supported by <a class="el" href="group___u_c_p___m_e_m.html#ga455313831b8734fe1a824109c3ffc588">ucp_mem_advise()</a> function. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga1a73c4a7fc1d8a6d75e6b53256eec0b8a3a335aa51dc934e57f4ccbd26fb32fb0"></a>UCP_MADV_NORMAL&#160;</td><td class="fielddoc">
<p>No special treatment </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1a73c4a7fc1d8a6d75e6b53256eec0b8a882711eaac0fe1172570783e9824e12f"></a>UCP_MADV_WILLNEED&#160;</td><td class="fielddoc">
<p>can be used on the memory mapped with <a class="el" href="group___u_c_p___m_e_m.html#gga06fc87d81c62e9abb8790b6e5713c55ba31fa3f795110becccb25734067b5e203">UCP_MEM_MAP_NONBLOCK</a> to speed up memory mapping and to avoid page faults when the memory is accessed for the first time. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga9143b85c7c40d6b13020a13bc13f9dbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_c_p___m_e_m.html#ga9143b85c7c40d6b13020a13bc13f9dbf">ucp_memh_pack_params_field</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The enumeration allows specifying which fields in <a class="el" href="group___u_c_p___m_e_m.html#gaa337a1ae88aed5f497d492d9406cf8c0">ucp_memh_pack_params_t</a> are present. It is used to enable backward compatibility support. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga9143b85c7c40d6b13020a13bc13f9dbfaa88937590bafafda1088444634173fa8"></a>UCP_MEMH_PACK_PARAM_FIELD_FLAGS&#160;</td><td class="fielddoc">
<p>Memory handle packing field that will be used in the <a class="el" href="group___u_c_p___m_e_m.html#ga8540eb3c5b885dfddbca0e39e00117ad">ucp_memh_pack</a> routine. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga83ac2dbb4fe6b93948b00c9a2ad16efe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_c_p___m_e_m.html#ga83ac2dbb4fe6b93948b00c9a2ad16efe">ucp_memh_pack_flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The enumeration list describes the memory handle packing flags supported by <a class="el" href="group___u_c_p___m_e_m.html#ga8540eb3c5b885dfddbca0e39e00117ad">ucp_memh_pack()</a> function. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga83ac2dbb4fe6b93948b00c9a2ad16efead1933cc321da0f7ab0428070d36d1e00"></a>UCP_MEMH_PACK_FLAG_EXPORT&#160;</td><td class="fielddoc">
<p>Pack a memory handle to be exported and used by peers for their local operations on a memory buffer allocated from same or another virtual memory space, but physically registered on the same network device. A peer should call <a class="el" href="group___u_c_p___m_e_m.html#ga1af508a609cc7f2cebf4b33f9ee6ac66">ucp_mem_map</a> with the flag <a class="el" href="group___u_c_p___m_e_m.html#gga1b78010c24c834aadc9fb8f1083e226faf130e704ffef248e615f5aeb25208ce9">UCP_MEM_MAP_PARAM_FIELD_EXPORTED_MEMH_BUFFER</a> in order to import and use a memory handle buffer obtained from <a class="el" href="group___u_c_p___m_e_m.html#ga8540eb3c5b885dfddbca0e39e00117ad">ucp_memh_pack</a>. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gab0d7a54391c964c59b2cfbf30e23dc14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_c_p___m_e_m.html#gab0d7a54391c964c59b2cfbf30e23dc14">ucp_mem_attr_field</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The enumeration allows specifying which fields in <a class="el" href="group___u_c_p___m_e_m.html#ga80089f1bd72dea239fbcb45bd6414c26">ucp_mem_attr_t</a> are present. It is used to enable backward compatibility support. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggab0d7a54391c964c59b2cfbf30e23dc14a7255d71b73495f3466b2b3938f85630f"></a>UCP_MEM_ATTR_FIELD_ADDRESS&#160;</td><td class="fielddoc">
<p>Virtual address </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab0d7a54391c964c59b2cfbf30e23dc14aaf7684459badd65a4e70a65813ae1e35"></a>UCP_MEM_ATTR_FIELD_LENGTH&#160;</td><td class="fielddoc">
<p>The size of memory region </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab0d7a54391c964c59b2cfbf30e23dc14a97c63bcd6332d0556e4439bc65531116"></a>UCP_MEM_ATTR_FIELD_MEM_TYPE&#160;</td><td class="fielddoc">
<p>Type of allocated or registered memory </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga1af508a609cc7f2cebf4b33f9ee6ac66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_mem_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga0e40ddc46f0bbe868a13f6ab1b674f76">ucp_context_h</a>&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_c_p___m_e_m.html#gaf20a30e6819c75f1a8a8727572661a99">ucp_mem_map_params_t</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gacf61d6417524329d75f239d3f2ea8d3b">ucp_mem_h</a> *&#160;</td>
          <td class="paramname"><em>memh_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine maps or/and allocates a user-specified memory segment with <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga0e40ddc46f0bbe868a13f6ab1b674f76">UCP application context</a> and the network resources associated with it. If the application specifies NULL as an address for the memory segment, the routine allocates a mapped memory segment and returns its address in the <em>address_p</em> argument. The network stack associated with an application context can typically send and receive data from the mapped memory without CPU intervention; some devices and associated network stacks require the memory to be mapped to send and receive data. The <a class="el" href="group___u_c_p___m_e_m.html#gacf61d6417524329d75f239d3f2ea8d3b">memory handle</a> includes all information required to access the memory locally using UCP routines, while <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote registration handle</a> provides an information that is necessary for remote memory access.</p>
<dl class="section note"><dt>Note</dt><dd>Another well know terminology for the "map" operation that is typically used in the context of networking is memory "registration" or "pinning". The UCP library registers the memory the available hardware so it can be assessed directly by the hardware.</dd></dl>
<p>Memory mapping assumptions: </p><ul>
<li>A given memory segment can be mapped by several different communication stacks, if these are compatible. </li>
<li>The <em>memh_p</em> handle returned may be used with any sub-region of the mapped memory. </li>
<li>If a large segment is registered, and then segmented for subsequent use by a user, then the user is responsible for segmentation and subsequent management.</li>
</ul>
<a class="anchor" id=""></a>
<table class="doxtable">
<caption>Matrix of behavior</caption>
<tr>
<th>parameter/flag </th><td align="center"><a class="el" href="group___u_c_p___m_e_m.html#gga06fc87d81c62e9abb8790b6e5713c55ba31fa3f795110becccb25734067b5e203">NONBLOCK</a> </td><td align="center"><a class="el" href="group___u_c_p___m_e_m.html#gga06fc87d81c62e9abb8790b6e5713c55ba8cb2c18c15da7e8da9aa2de5b407957a">ALLOCATE</a> </td><td align="center"><a class="el" href="group___u_c_p___m_e_m.html#gga06fc87d81c62e9abb8790b6e5713c55ba937051276d5a7825211189c84d7f2922">FIXED</a> </td><td align="center"><a class="el" href="group___u_c_p___m_e_m.html#acc3761c4bbcca9c1defa742a8db08bbb">address</a> </td><td align="center"><b>result</b> </td></tr>
<tr>
<td rowspan="8" align="center"><b>value</b> </td><td rowspan="8" align="center">0/1 - the value<br />
 only affects the<br />
 register/map<br />
 phase </td><td align="center">0 </td><td align="center">0 </td><td align="center">0 </td><td align="center"><a class="el" href="group___u_c_p___m_e_m.html#anch_err">error</a> if length &gt; 0 </td></tr>
<tr>
<td align="center">1 </td><td align="center">0 </td><td align="center">0 </td><td align="center"><a class="el" href="group___u_c_p___m_e_m.html#anch_alloc_reg">alloc+register</a> </td></tr>
<tr>
<td align="center">0 </td><td align="center">1 </td><td align="center">0 </td><td align="center"><a class="el" href="group___u_c_p___m_e_m.html#anch_err">error</a> </td></tr>
<tr>
<td align="center">0 </td><td align="center">0 </td><td align="center">defined </td><td align="center"><a class="el" href="group___u_c_p___m_e_m.html#anch_reg">register</a> </td></tr>
<tr>
<td align="center">1 </td><td align="center">1 </td><td align="center">0 </td><td align="center"><a class="el" href="group___u_c_p___m_e_m.html#anch_err">error</a> </td></tr>
<tr>
<td align="center">1 </td><td align="center">0 </td><td align="center">defined </td><td align="center"><a class="el" href="group___u_c_p___m_e_m.html#anch_alloc_hint_reg">alloc+register,hint</a> </td></tr>
<tr>
<td align="center">0 </td><td align="center">1 </td><td align="center">defined </td><td align="center"><a class="el" href="group___u_c_p___m_e_m.html#anch_err">error</a> </td></tr>
<tr>
<td align="center">1 </td><td align="center">1 </td><td align="center">defined </td><td align="center"><a class="el" href="group___u_c_p___m_e_m.html#anch_alloc_fixed_reg">alloc+register,fixed</a> </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li><a class="anchor" id="anch_reg"></a><b>register</b> means that the memory will be registered in corresponding transports for RMA/AMO operations. This case intends that the memory was allocated by user before. </li>
<li><a class="anchor" id="anch_alloc_reg"></a><b>alloc+register</b> means that the memory will be allocated in the memory provided by the system and registered in corresponding transports for RMA/AMO operations. </li>
<li><a class="anchor" id="anch_alloc_hint_reg"></a><b>alloc+register,hint</b> means that the memory will be allocated with using <a class="el" href="group___u_c_p___m_e_m.html#acc3761c4bbcca9c1defa742a8db08bbb">ucp_mem_map_params::address</a> as a hint and registered in corresponding transports for RMA/AMO operations. </li>
<li><a class="anchor" id="anch_alloc_fixed_reg"></a><b>alloc+register,fixed</b> means that the memory will be allocated and registered in corresponding transports for RMA/AMO operations. </li>
<li><a class="anchor" id="anch_err"></a><b>error</b> is an erroneous combination of the parameters.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Application <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga0e40ddc46f0bbe868a13f6ab1b674f76">context</a> to map (register) and allocate the memory on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>User defined <a class="el" href="group___u_c_p___m_e_m.html#gaf20a30e6819c75f1a8a8727572661a99">ucp_mem_map_params_t</a> configurations for the <a class="el" href="group___u_c_p___m_e_m.html#gacf61d6417524329d75f239d3f2ea8d3b">UCP memory handle</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">memh_p</td><td>UCP <a class="el" href="group___u_c_p___m_e_m.html#gacf61d6417524329d75f239d3f2ea8d3b">handle</a> for the allocated segment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac8bd616375fe05594690b5e0cddd6318"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_mem_unmap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga0e40ddc46f0bbe868a13f6ab1b674f76">ucp_context_h</a>&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gacf61d6417524329d75f239d3f2ea8d3b">ucp_mem_h</a>&#160;</td>
          <td class="paramname"><em>memh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine unmaps a user specified memory segment, that was previously mapped using the <a class="el" href="group___u_c_p___m_e_m.html#ga1af508a609cc7f2cebf4b33f9ee6ac66">ucp_mem_map()</a> routine. The unmap routine will also release the resources associated with the memory <a class="el" href="group___u_c_p___m_e_m.html#gacf61d6417524329d75f239d3f2ea8d3b">handle</a>. When the function returns, the <a class="el" href="group___u_c_p___m_e_m.html#gacf61d6417524329d75f239d3f2ea8d3b">ucp_mem_h</a> and associated <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote key</a> will be invalid and cannot be used with any UCP routine.</p>
<dl class="section note"><dt>Note</dt><dd>Another well know terminology for the "unmap" operation that is typically used in the context of networking is memory "de-registration". The UCP library de-registers the memory the available hardware so it can be returned back to the operation system.</dd></dl>
<p>Error cases: </p><ul>
<li>Once memory is unmapped a network access to the region may cause a failure.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Application <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga0e40ddc46f0bbe868a13f6ab1b674f76">context</a> which was used to allocate/map the memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memh</td><td><a class="el" href="group___u_c_p___m_e_m.html#gacf61d6417524329d75f239d3f2ea8d3b">Handle</a> to memory region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga080c10aaf347682594092d796bbc913f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_mem_query </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___u_c_p___m_e_m.html#gacf61d6417524329d75f239d3f2ea8d3b">ucp_mem_h</a>&#160;</td>
          <td class="paramname"><em>memh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#ga80089f1bd72dea239fbcb45bd6414c26">ucp_mem_attr_t</a> *&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns address and length of memory segment mapped with <a class="el" href="group___u_c_p___m_e_m.html#ga1af508a609cc7f2cebf4b33f9ee6ac66">ucp_mem_map()</a> routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">memh</td><td><a class="el" href="group___u_c_p___m_e_m.html#gacf61d6417524329d75f239d3f2ea8d3b">Handle</a> to memory region. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">attr</td><td>Filled with attributes of the <a class="el" href="group___u_c_p___m_e_m.html#gacf61d6417524329d75f239d3f2ea8d3b">UCP memory handle</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3240a60d906b2ecf5d0a19acdf13850f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucp_mem_print_info </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mem_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga0e40ddc46f0bbe868a13f6ab1b674f76">ucp_context_h</a>&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine maps memory and prints information about the created memory handle: including the mapped memory length, the allocation method, and other useful information associated with the memory handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mem_spec</td><td>Size and optional type of the memory to map. The format of the string is: "&lt;size&gt;[,&lt;type&gt;]". For example:<ul>
<li>"32768" : allocate 32 kilobytes of host memory.</li>
<li>"1m,cuda" : allocate 1 megabayte of cuda memory. </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context on which the memory is mapped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>Output stream on which to print the information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga455313831b8734fe1a824109c3ffc588"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_mem_advise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga0e40ddc46f0bbe868a13f6ab1b674f76">ucp_context_h</a>&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gacf61d6417524329d75f239d3f2ea8d3b">ucp_mem_h</a>&#160;</td>
          <td class="paramname"><em>memh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#ga6d5e3085cb8086de3592e15cc19a3b50">ucp_mem_advise_params_t</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine advises the UCP about how to handle memory range beginning at address and size of length bytes. This call does not influence the semantics of the application, but may influence its performance. The UCP may ignore the advice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Application <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga0e40ddc46f0bbe868a13f6ab1b674f76">context</a> which was used to allocate/map the memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memh</td><td><a class="el" href="group___u_c_p___m_e_m.html#gacf61d6417524329d75f239d3f2ea8d3b">Handle</a> to memory region. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Memory base address and length. The advice field is used to pass memory use advice as defined in the <a class="el" href="group___u_c_p___m_e_m.html#ga1a73c4a7fc1d8a6d75e6b53256eec0b8">ucp_mem_advice</a> list The memory range must belong to the <em>memh</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8540eb3c5b885dfddbca0e39e00117ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_memh_pack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gacf61d6417524329d75f239d3f2ea8d3b">ucp_mem_h</a>&#160;</td>
          <td class="paramname"><em>memh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_c_p___m_e_m.html#gaa337a1ae88aed5f497d492d9406cf8c0">ucp_memh_pack_params_t</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>buffer_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>buffer_size_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine allocates a memory buffer and packs a memory handle into the buffer. A packed memory key is an opaque object that provides the information that is necessary for a peer. This routine packs the memory handle in a portable format such that the object can be unpacked on any platform supported by the UCP library, e.g. if the memory handle was packed as a remote memory key (RKEY), it should be unpacked by <a class="el" href="group___u_c_p___m_e_m.html#ga92353d1cb038a4e281f0a1973937079d">ucp_ep_rkey_unpack()</a>. In order to release the memory buffer allocated by this routine, the application is responsible for calling the <a class="el" href="group___u_c_p___m_e_m.html#gab016c446e78e171c03a2fe11ab5fe48d">ucp_memh_buffer_release()</a> routine.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>RKEYs for InfiniBand and Cray Aries networks typically includes InfiniBand and Aries key. </li>
<li>In order to enable remote direct memory access to the memory associated with the memory handle the application is responsible for sharing the RKEY with the peers that will initiate the access.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">memh</td><td><a class="el" href="group___u_c_p___m_e_m.html#gacf61d6417524329d75f239d3f2ea8d3b">Handle</a> to memory region. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Memory handle packing parameters, as defined by <a class="el" href="group___u_c_p___m_e_m.html#gaa337a1ae88aed5f497d492d9406cf8c0">ucp_memh_pack_params_t</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer_p</td><td>Memory buffer allocated by the library. The buffer contains the packed memory handle. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer_size_p</td><td>Size (in bytes) of the buffer which contains packed memory handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab016c446e78e171c03a2fe11ab5fe48d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucp_memh_buffer_release </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_c_p___m_e_m.html#ga0eab5641bbc55da181862a06d4d79101">ucp_memh_buffer_release_params_t</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine releases the buffer that was allocated using <a class="el" href="group___u_c_p___m_e_m.html#ga8540eb3c5b885dfddbca0e39e00117ad">ucp_memh_pack()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd><ul>
<li>Once memory is released, an access to the memory may cause undefined behavior. </li>
<li>If the input memory address was not allocated using <a class="el" href="group___u_c_p___m_e_m.html#ga8540eb3c5b885dfddbca0e39e00117ad">ucp_memh_pack()</a> routine, the behavior of this routine is undefined.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Buffer to release. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Memory handle buffer release parameters, as defined by <a class="el" href="group___u_c_p___m_e_m.html#ga0eab5641bbc55da181862a06d4d79101">ucp_memh_buffer_release_params_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga92353d1cb038a4e281f0a1973937079d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_ep_rkey_unpack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>rkey_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> *&#160;</td>
          <td class="paramname"><em>rkey_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine unpacks the remote key (RKEY) object into the local memory such that it can be accessed and used by UCP routines. The RKEY object has to be packed using the <a class="el" href="group___u_c_p___m_e_m.html#gadbb6b3ace4ab988cd7660319123407b4">ucp_rkey_pack()</a> routine. Application code should not make any changes to the content of the RKEY buffer.</p>
<dl class="section note"><dt>Note</dt><dd>The application is responsible for releasing the RKEY object when it is no longer needed, by calling the <a class="el" href="group___u_c_p___m_e_m.html#gae33d7cc264e0fe1b11e27ae4289fba39">ucp_rkey_destroy()</a> routine. </dd>
<dd>
The remote key object can be used for communications only on the endpoint on which it was unpacked.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint to access using the remote key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey_buffer</td><td>Packed rkey. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rkey_p</td><td>Remote key handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga68f3458805ba15d6a5883219ecd56c1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_rkey_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>raddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>addr_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns a local pointer to the remote memory described by the rkey.</p>
<dl class="section note"><dt>Note</dt><dd>This routine can return a valid pointer only for the endpoints that are reachable via shared memory.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>A remote key handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">raddr</td><td>A remote memory address within the memory area described by the rkey. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">addr_p</td><td>A pointer that can be used for direct access to the remote memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> if the remote memory cannot be accessed directly or the remote memory address is not valid. </dd></dl>

</div>
</div>
<a class="anchor" id="gae33d7cc264e0fe1b11e27ae4289fba39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucp_rkey_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine destroys the RKEY object and the memory that was allocated using the <a class="el" href="group___u_c_p___m_e_m.html#ga92353d1cb038a4e281f0a1973937079d">ucp_ep_rkey_unpack()</a> routine. This routine also releases any resources that are associated with the RKEY object.</p>
<dl class="section warning"><dt>Warning</dt><dd><ul>
<li>Once the RKEY object is released an access to the memory will cause an undefined failure. </li>
<li>If the RKEY object was not created using <a class="el" href="group___u_c_p___m_e_m.html#ga92353d1cb038a4e281f0a1973937079d">ucp_ep_rkey_unpack()</a> routine the behavior of this routine is undefined. </li>
<li>The RKEY object must be destroyed after all outstanding operations which are using it are flushed, and before the endpoint on which it was unpacked is destroyed.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote key to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadbb6b3ace4ab988cd7660319123407b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_rkey_pack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga0e40ddc46f0bbe868a13f6ab1b674f76">ucp_context_h</a>&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gacf61d6417524329d75f239d3f2ea8d3b">ucp_mem_h</a>&#160;</td>
          <td class="paramname"><em>memh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>rkey_buffer_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___m_e_m.html#ga8540eb3c5b885dfddbca0e39e00117ad">ucp_memh_pack()</a>. </dd></dl>
<p>This routine allocates a memory buffer and packs a remote access key (RKEY) object into it. RKEY is an opaque object that provides the information that is necessary for remote memory access. This routine packs the RKEY object in a portable format such that the object can be <a class="el" href="group___u_c_p___m_e_m.html#ga92353d1cb038a4e281f0a1973937079d">unpacked</a> on any platform supported by the UCP library. In order to release the memory buffer allocated by this routine, the application is responsible for calling the <a class="el" href="group___u_c_p___m_e_m.html#ga8bc005f53da015f4a062087e6eb064e9">ucp_rkey_buffer_release()</a> routine.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>RKEYs for InfiniBand and Cray Aries networks typically include the InfiniBand and Aries key. </li>
<li>In order to enable remote direct memory access to the memory associated with the memory handle, the application is responsible for sharing the RKEY with the peers that will initiate the access.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Application <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga0e40ddc46f0bbe868a13f6ab1b674f76">context</a> which was used to allocate/map the memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memh</td><td><a class="el" href="group___u_c_p___m_e_m.html#gacf61d6417524329d75f239d3f2ea8d3b">Handle</a> to the memory region. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rkey_buffer_p</td><td>Memory buffer allocated by the library. The buffer contains the packed RKEY. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size_p</td><td>Size (in bytes) of the packed RKEY.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8bc005f53da015f4a062087e6eb064e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucp_rkey_buffer_release </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rkey_buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___m_e_m.html#gab016c446e78e171c03a2fe11ab5fe48d">ucp_memh_buffer_release()</a>. </dd></dl>
<p>This routine releases the buffer that was allocated using <a class="el" href="group___u_c_p___m_e_m.html#gadbb6b3ace4ab988cd7660319123407b4">ucp_rkey_pack()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd><ul>
<li>Once memory is released, an access to the memory may cause undefined behavior. </li>
<li>If the input memory address was not allocated using <a class="el" href="group___u_c_p___m_e_m.html#gadbb6b3ace4ab988cd7660319123407b4">ucp_rkey_pack()</a> routine, the behavior of this routine is undefined.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey_buffer</td><td>Buffer to release. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Mar 13 2023 22:58:16 for UCX by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
